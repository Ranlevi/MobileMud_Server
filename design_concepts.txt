Game Design:
============
- encourage role playing
- Long messages can be broken into multiple msgs. Next, End commands.

- Coins:
  Digital economy. The coins are kept in a balance.
  Maybe a 'transfer X #' command. 
  User do tasks and get payed to the balance.

 Shops:
  User says 'buy'. shopkeeper gives a messgage chain with numbered list. say 'buy 1' buys.
  same for 'sell' -> 'sell 1'.

- look cmd can accept ids for specific item selection. (look and inv should
return id as metadata, and client should enable copying it for long numbers.)

Architecture:
==================

- Client for sending inputs and displaying content only. All game
  logic is handled on the backend.
  - demo client assumes text input only

- The base class for everything in the world is Item. 
    Every item in the game has some basic default parameters and methods.
    Every Item has an ID number. Almost all functions accept ids as inputs.
    Every Item can be a container, and so has methods for adding/removing other entities.
  Under item: 
    -Room.
    -Entity.
      Everything which is not a room is an entity. 
      An entity is always in a container (a room or some other container.)
      It has an inventory (although by default it can't be used.) A non-Human
      entity will usually have only slots.
      By default, it doesn't have a name.
  Under Entity:
    -AnimatedObject:
      All NPCs that can interact with the users. 
      It has health and damage, and can do battles. 
      It has a name.
  Under AnimatedObject:
    - User: 
      Has a standard inventory.
      Has a message Queue.
      Has a password.
      
- All Items are stored in a World Map() object, as id:instance pairs.

- Some common component of the game are implemented as Singletons, so a single
  instance can be used in all parts of the game (e.g. Message Sender, Message Formatter, etc.)

- All items are independant, and take care of their own internal state via proces_tick().
  When something that requires synchorization with another item ocurrs (e.g. battle),
  the game_loop() ignores the process_tick and handles the actions directly.

- Messages are sent async. Game has a 1 sec tick for entities.

- Composition is key. Keep mechanics simple, and build with them.

- Game content creation should be flexable, to allow any to create new games 
  using existing types.
  - defined by loading a JSON when the engine boots. 
- Two basic modes: 
  - Adventure: users interact with the world, create stuff according
    to what's available.
  - Creative: users interactivly create the world.
    - creating rooms and npcs. modifying properties via 'modify room.name' etc.
    - set/release ownership of rooms and objects.
  The two can be in the same game, but in different zones. 
                                                           
- Development phases:
  - Basic World, single user moving around. look command.
    - changing client backgroud dynamically.
    - assigning typography according to type.   
    - saving and loading users.
  - Add objects and basic interactions: look, get, drop, hold, use.
    - Add inventory, slots to user.
  - Add NPCs and basic interactions: look, say. user sees what npc does.
    - handle damage, death (corpse is an entity)
  - Add object creation: create (based on objects in inventory)
  - Add economy: coins, player wallet. buy/sell from inventory to npc.
  - add inter-user interactions: tell. 
  - Add tests
-There is a process of discovery happening for players on the planet. We need millions
of rooms, so probably a random romm generator with diferent bioms, like
minecraft.
-Quests will lead to the discovery of the story's apex. We ask the
players to keep it a secret from others. It won't work but will create
better cohesion with the players who take the game seriously. 
- Going deeper into the planet makes it more dangeours, thus creating 
a natural leveling/zoning system.


- The economy is based on raw materials mined/found in the deeper levels.
  - the basic 'source' of new value are the materials. It has a natural
    feedback loop: more players = more mining = more value.
  - This casues inflation, so we need a sink to remove value from the game to
    prevent the coin being less and less valuable. 
    Two sinks: one is player growth, which creates demand for coin and thus
    fights inflation. The other is items being 
    broken/vanishing, which removes value from the game.
  - We can create a link between the number of new players in the game
    to the rate of new mateial discovery, rate of decay of items.
- Users will have no classes/gender: only self description and items owned.
  - Curiosity will be awarded with new recipies for creating unique and helpful
    items.
- Recipe book will use the concept of chained messages: messages with a 
  next/back button (or next/back commands). 
  This will allow short messages that will not force the user to read loading
  messages, which are equal to 'being blind'. 
- We want to engage the user's imagination, to make them 'see' the world in their
  mind's eye. So we ned to create strong signals for linking the text to 'mental
  pictures'. 
    - Backgroud color of the chat interface.
    - Messages boxes: different colors, border thickness and color,
      shapes, whitespace.
    - Typography for the text.
  This will not be random, but will have some intenral logic.

  